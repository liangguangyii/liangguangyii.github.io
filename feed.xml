<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://liangguangyii.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://liangguangyii.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-06-10T12:56:11+00:00</updated><id>https://liangguangyii.github.io/feed.xml</id><title type="html">blank</title><subtitle>Ho! So many bugs and goblins in my life! </subtitle><entry><title type="html">Classical Electrodynamics</title><link href="https://liangguangyii.github.io/blog/2024/notes-for-classical-electric-dynamic/" rel="alternate" type="text/html" title="Classical Electrodynamics"/><published>2024-06-09T00:00:00+00:00</published><updated>2024-06-09T00:00:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-for-classical-electric-dynamic</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-for-classical-electric-dynamic/"><![CDATA[<h1 id="the-general-maxwell-lorentz-theory">The General Maxwell-Lorentz Theory</h1> <h2 id="basic-equations">Basic Equations</h2> <p>Maxwell’s equations:</p> \[\begin{aligned} \nabla \times \vec{E} + \frac{1}{c} \dot{\vec{H}} &amp; = 0, \\ \nabla \cdot \vec{E} &amp; = 4 \pi \rho, \\ \nabla \times \vec{H} - \frac{1}{c} \dot{\vec{E}} &amp; = \frac{4 \pi}{c} \rho \vec{v}, \\ \nabla \cdot \vec{H} &amp; = 0, \end{aligned}\] <p>Equation of continuity:</p> \[\nabla \cdot (\rho \vec{v}) + \dot{\rho} = 0,\] <p>Lorentz euqation gives the description of the motion of a charged particle in an electromagnetic field:</p> \[\vec{k} = \rho ( \vec{E} + \frac{1}{c} \vec{v} \times \vec{H} ),\] <p>Where \(\vec{k}\) is the density of force acting on the charge density \(\rho\).</p> <h2 id="potentials">Potentials</h2> <p>Define the vector \(\vec{A}\):</p> \[\vec{H} = \nabla \times \vec{A},\] <p>Then we have(from Maxwell-Lorentz equations): \(\nabla \times (\vec{E} + \frac{1}{c} \dot{\vec{A}}) = 0,\)</p> <p>Which means \(\vec{E} + \frac{1}{c} \dot{\vec{A}} \propto \nabla f\), so that:</p> \[\begin{aligned} \vec{H} &amp; = \nabla \times \vec{A}, \\ \vec{E} + \frac{1}{c} \dot{\vec{A}} &amp; = - \nabla \phi, \end{aligned}\] <p>The definition of these two potentials has already satisfied the first and the fourth Maxwell-Lorentz equations. The second and the third equations could be rewritten as:</p> <p>\begin{equation} \begin{aligned} -\nabla^2 \phi - \frac{1}{c^2} \nabla \cdot \dot{\vec{A}} &amp; = 4 \pi \rho, <br/> \frac{1}{c^2} \ddot{\vec{A}} - \nabla^2 \vec{A} + \nabla(\nabla \cdot \vec{A} + \frac{1}{c} \dot{\phi}) &amp; = \frac{4 \pi}{c} \rho \vec{v}, <br/> \label{eq:modified-maxwell-lorentz} \end{aligned} \end{equation}</p> <h2 id="gauge-transformation">Gauge Transformation</h2> <p>The vector potential is not unique, as we could add a gradient of any scalar function to it and \(\vec{A}\) still satisfies its definition \(\vec{H} = \nabla \times \vec{A}\). There are two common choices of gauge transformation, Lorentz gauge and Coulomb gauge.</p> <p>The Lorentz gauge writes:</p> \[\nabla \cdot \vec{A} + \frac{1}{c} \dot{\phi} = 0,\] <p>And the Coulomb gauge writes:</p> \[\nabla \cdot \vec{A} = 0,\] <h2 id="retarded-potentials">Retarded Potentials</h2> <p>In Lorentz gauge, \eqref{eq:modified-maxwell-lorentz} could be rewritten as:</p>]]></content><author><name></name></author><category term="Theory"/><category term="Electrodynamics"/><summary type="html"><![CDATA[The General Maxwell-Lorentz Theory Basic Equations]]></summary></entry><entry><title type="html">Higher-order response in quantum mechanics</title><link href="https://liangguangyii.github.io/blog/2024/notes-phy-higher-order-response/" rel="alternate" type="text/html" title="Higher-order response in quantum mechanics"/><published>2024-03-22T15:01:00+00:00</published><updated>2024-03-22T15:01:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-phy-higher-order-response</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-phy-higher-order-response/"><![CDATA[<h1 id="convolution">Convolution</h1> \[\begin{aligned} (f*g)(t) &amp; = \int_{-\infty}^{\infty} \rm{d} \tau f(t-\tau) g(\tau) ,\\ (f*g)(t) &amp; \leftrightarrow F(\omega) G(\omega) ,\\ \end{aligned}\] <p>Here is the proof:</p> <p>For the transformation from time domain to frequency domain:</p> \[\begin{aligned} \int_{-\infty}^{\infty} \rm{d} t e^{i \omega t} (f*g)(t) &amp; = \int_{-\infty}^{\infty} \rm{d} t e^{i \omega t} \int_{-\infty}^{\infty} \rm{d} \tau f(t-\tau) g(\tau) ,\\ &amp; = \int_{-\infty}^{\infty} \rm{d} t \int_{-\infty}^{\infty} \rm{d} \tau e^{i \omega (t - \tau)} e^{i \omega \tau} f(t - \tau) g(\tau) ,\\ &amp; = \int_{-\infty}^{\infty} \rm{d} t_1 \int_{-\infty}^{\infty} \rm{d} t_2 e^{i \omega t_1} e^{i \omega t_2} f(t_1) g(t_2) ,\\ \end{aligned}\] <p>Where we have used the Jacobian transformation \(t_1 = t -\tau, \ t_2= \tau, \ \frac{\partial (t_1, t_2) }{\partial (t, \tau) } = 1\).</p> <p>For the transformation from frequency domain to time domain:</p> \[\begin{aligned} \int_{-\infty}^{\infty} \rm{d} \omega e^{-i \omega t} F(\omega) G(\omega) &amp; = \int_{-\infty}^{\infty} \rm{d} \omega \int_{-\infty}^{\infty} \rm{d} \tau e^{-i \omega t} e^{i \omega \tau} F(\omega) g(\tau) ,\\ \end{aligned}\] <h1 id="interaction-picture">Interaction picture</h1> \[\begin{aligned} &amp; \psi^I (t) = e^{i H_0 t} \psi^S (t), \\ &amp; \hat{O}^I (t) = e^{i H_0 t} \hat{O}^S e^{-i H_0 t}, \\ \end{aligned}\] <p>And</p> \[\begin{aligned} i \frac{\partial}{\partial t} \psi^I (t) &amp; = H^I \psi^I (t), \\ i \frac{\partial}{\partial t} \hat{O}^I (t) &amp; = [ \hat{O}^I (t), H_0], \\ \end{aligned}\] <p>And the time-evolution operator in the interaction picture is:</p> \[\begin{aligned} U (t, t_0) \Psi^I (t_0) &amp; = \Psi^I (t) ,\\ i \frac{\partial}{\partial t} U (t, t_0) &amp; = H^I (t) U (t, t_0), \\ \end{aligned}\] <p>Where \(\Psi^I (t_0)\) could be viewed as the wavefunction in Heisenberg picture. And in Schrödinger picture, it turns to:</p> \[\Psi^S (t) = e^{-i H_0 t} U(t, t_0) \Psi^H,\] <p>By solving the equation of motion, we get \(U = \hat{T} \exp (- i \int_{t_0}^t \rm{d} t' H_1^I (t'))\), where \(\hat{T}\) is the time-ordering operator.</p> \[\begin{aligned} \hat{T} [a_1(t_1) a_2 (t_2) \cdots a_n(t_n) ] &amp; = \sum_{P \rightarrow \alpha \beta \cdots \zeta} a_{\alpha} (t_{\alpha}) a_{\beta} (t_{\beta}) \cdots a_{\zeta} (t_{\zeta}), \quad \rm{for} \ t_{\alpha} \geq t_{\beta} \cdots \geq t_{\zeta} ,\\ &amp; = \sum_{P \rightarrow \alpha \beta \cdots \zeta} \theta (t_{\alpha} - t_{\beta}) \theta (t_{\beta} - t_{\gamma}) \cdots \theta (t_{\xi} - t_{\zeta}) a_{\alpha} (t_{\alpha}) a_{\beta} (t_{\beta}) \cdots a_{\zeta} (t_{\zeta}),\\ \end{aligned}\] \[\int_{t_0}^t \rm{d} t_1 \int_{t_0}^t \rm{d} t_2 \cdots \int_{t_0}^t \rm{d} t_n \hat{T} [H_1^I (t_1) H_1^I (t_2) \cdots H_1^I (t_n)] = n! \int_{t_0}^t \rm{d} t_1 \int_{t_0}^{t_1} \rm{d} t_2 \cdots \int_{t_0}^{t_{n-1}} \rm{d} t_n H_1^I (t_1) H_1^I (t_2) \cdots H_1^I (t_n),\] <p>And wick theorem could be used to simplify the calculation of the expectation value of the time-ordered operator in vacuum state:</p> <p>\(\hat{T} [a_1(t_1) a_2 (t_2) \cdots a_n(t_n) ] = \hat{N} [a_1(t_1) a_2 (t_2) \cdots a_n(t_n) ] + \rm{all \ possible \ contractions}\) \(\langle 0 | \hat{T} [a_1(t_1) a_2 (t_2) \cdots a_n(t_n) ] | 0 \rangle = \langle 0 | \rm{all \ possible \ contractions} | 0 \rangle\)</p> <h1 id="response-theory">Response theory</h1> <h2 id="baker-campbell-hausdorf-formula">Baker-Campbell-Hausdorf formula</h2> \[\begin{aligned} e^A B e^{-A} &amp; = B + [A, B] + \frac{1}{2!} [A, [A, B]] + \frac{1}{3!} [A, [A, [A, B]]] + \cdots , \\ e^{-A} B e^{A} &amp; = B - [A, B] + \frac{1}{2!} [A, [A, B]] - \frac{1}{3!} [A, [A, [A, B]]] + \cdots , \\ &amp; = B + [B,A] + \frac{1}{2!} [[B,A],A] + \frac{1}{3!} [[[B,A],A],A] + \cdots ,\\ \end{aligned}\] <p>Consider a fucntion of x:</p> \[F(x) = e^{Ax} Bx e^{-Ax},\] \[\begin{aligned} \frac{\partial }{\partial x} \{ F(x) \} &amp; = [A, F(x)], \ \frac{\partial^n }{\partial x^n} \{ F(x) \} &amp; = [A, \cdots [A, F(x)]], \\ \end{aligned}\] <p>And the more general form of BCH formula is:</p> \[e^A e^B = \exp (A + B + \frac{1}{2} [A,B] + \frac{1}{12} [A,[A,B]] + \frac{1}{12} [B,[B,A]] + \cdots )\] <p>Considering \(G(x)\), satisfying \(e^{Ax} e^{Bx} = e^{G(x)}\), and the operator \(\frac{\partial}{\partial x}\) could be viewed as a single body operator, and satisfy the relationship \(\frac{\partial}{\partial x} \rightarrow 0, \ F(A) \frac{\partial}{\partial x} \rightarrow 0\), because only A contains the parameter x. That is, \([A(x), \frac{\partial}{\partial x}] F(A) = (A \frac{\partial}{\partial x} - \frac{\partial}{\partial x} A ) F(A) = - (\frac{\partial}{\partial x} A(x)) F(x)\), then we have: \(\begin{aligned} e^{G(x)} \frac{\partial}{\partial x} e^{-G(x)} &amp; = - G'(x) - \frac{1}{2!} [G(x), G'(x)] - \frac{1}{3!} [G(x), [G(x), G'(x)]] - \cdots , \\ e^{- G(x)} \frac{\partial}{\partial x} e^{ G(x)} &amp; = G'(x) + \frac{1}{2!} [G'(x), G(x)] + \frac{1}{3!} [[G'(x), G(x)],G(x)] + \cdots , \\ \end{aligned}\)</p> <p>And</p> \[\begin{aligned} e^{-Bx}e^{-Ax} \frac{\partial}{\partial x} \{ e^{Ax} e^{Bx} \} &amp; = e^{-Bx} A e^{Bx} + B ,\\ &amp; = B + x [A,B] + \frac{x^2}{2!} [[A,B],B] + \frac{x^3}{3!} [[[A,B],B],B] + \cdots ,\\ \end{aligned}\] <p>And by using the Taylor expansion of \(G(x)\), we know:</p> \[\begin{aligned} &amp; G(x) = G_1 x + G_2 x^2 + G_3 x^3, \ G_0 = 0,\\ &amp; G'(x) = G_1 + 2! \times G_2 x + 3! \times G_3 x^2 + \cdots ,\\ \end{aligned}\] <p>Then:</p> \[\begin{aligned} e^{- G(x)} \frac{\partial}{\partial x} e^{ G(x)} &amp; = G'(x) + \frac{1}{2!} [G'(x), G(x)] + \frac{1}{3!} [[G'(x), G(x)],G(x)] + \cdots , \\ &amp; = G_1 + 2x G_2 + x^2 (3G_3 - \frac{1}{2}[G_1,G_2]) + \cdots,\\ \end{aligned}\] <h2 id="response-function">Response function</h2> \[\begin{aligned} \langle O(t) \rangle &amp; = \langle U^{\dagger} (t,t_0) O^I(t) U(t,t_0) \rangle_0 ,\\ &amp; = \langle \{ \hat{T} \exp (i \int_{t_0}^t \rm{d} t' H_1^I (t') ) \} O^I(t) \{ \hat{T} \exp (-i \int_{t_0}^t \rm{d} t' H_1^I (t') ) \} \rangle_0 ,\\ \end{aligned}\]]]></content><author><name></name></author><category term="Physics"/><category term="Quantum mechanics"/><summary type="html"><![CDATA[Convolution]]></summary></entry><entry><title type="html">TDDFT theory</title><link href="https://liangguangyii.github.io/blog/2024/notes-phy-tddft/" rel="alternate" type="text/html" title="TDDFT theory"/><published>2024-03-11T15:01:00+00:00</published><updated>2024-03-11T15:01:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-phy-tddft</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-phy-tddft/"><![CDATA[<h2 id="basic-pictures-in-schrödinger-equation">Basic pictures in Schrödinger equation</h2> <p>Schrödinger equation could be written as follows:</p> \[i \hbar \frac{\partial}{\partial t} \Psi(\vec{r}, t) = \hat{H} \Psi(\vec{r},t), \ \hat{H} = \frac{\vec{\hat{p}}^2}{2m} + V(\vec{r}), \ \vec{\hat{p}} = - \frac{i}{\hbar} \nabla,\] <p>And the stationary Schrödinger equation is:</p> \[\hat{H} \Phi(\vec{r}) = E_{n} \Phi_{n}(\vec{r}),\] <p>Where \(\Psi_n^{S} (\vec{r}, t) = \exp(-\frac{i}{\hbar} E_{n}) \phi_{n}(\vec{r})\), and the operators are all time-indenpendent, it’s called Schrödinger picture. The transition matrix elements are given as:</p> \[O_{mn} (t) = \langle \Psi_m^S | \hat{O}^S | \Psi_n^S \rangle\] <h3 id="heisenberg-picture">Heisenberg picture</h3> <p>In Heisenberg picture, the operators are time-dependent, and the wave function is time-independent. The wavefunction in Heisenberg picture is given as:</p> \[\Psi^{H} (\vec{r}) = \exp(\frac{i}{\hbar} \hat{H} t) \Psi^{S}(\vec{r}, t)\] <p>Operators in Heisenberg picture have the following form:</p> \[\hat{O}^{H} (t) = \exp(\frac{i}{\hbar} \hat{H} t) \hat{O}^{S} \exp(-\frac{i}{\hbar} \hat{H} t)\] <p>The motion of equation for operators in Heisenberg picture is given as:</p> \[i \hbar \frac{\partial }{ \partial t} \hat{O}^{H} (t) = [\hat{O}^{H}(t), \hat{H}]\] <p>Then the transition matrix is:</p> \[O_{mn} = \langle \Psi_m^H | \hat{O}^H(t) | \Psi_n^H \rangle= \langle \Psi_m^S | \hat{O}^S | \Psi_n^S \rangle\] <h3 id="interaction-picture">Interaction picture</h3> <p>In interaction picture, the wave function and operators are both time-dependent, the main difference is the seperation of the orginal Hamiltonian and the interaction Hamiltonian:</p> \[\Psi^{I} (\vec{r}, t ) = \exp(\frac{i}{\hbar} \hat{H}_{0} t ) \Psi^{S} (\vec{r}, t ),\] \[\hat{O}^{I} = \exp(\frac{i}{\hbar} \hat{H}_{0} t ) \hat{O}^{S} \exp( - \frac{i}{\hbar} \hat{H}_{0} t ),\] <p>The motion of equations are:</p> \[i \hbar \frac{\partial}{\partial t} \Psi^{I} (\vec{r},t) = \hat{H}_{1}^{I} \Psi^{I}(\vec{r}, t),\] \[i \hbar \frac{\partial}{\partial t} \hat{O}^{I}(t) = [\hat{O}^{I}(t), \hat{H}_0],\] <h3 id="transformation-between-interaction-and-heisenberg-picture">Transformation between Interaction and Heisenberg picture</h3> <p>In Heisenberg picture, the wavefunction is time-independent, si that \(\Psi^S(0) = \Psi^I(0) = \Psi^H\), that is the reason why the transition to Heisenberg picture is important.</p> <p>Then the time evolution of \(\Psi^I\) becomes the transformation between Interaction and Heisenberg picture:</p> \[\Psi^I (t) = U(t,0) \Psi^I(0) = U(t,0) \Psi^H,\] \[U(t_1,t_2) = U(t_1 - t_2) = \exp(\frac{i}{\hbar}H_0 \Delta t) \exp(-\frac{i}{\hbar}H \Delta t),\] <p>Time evolution operator \(U(t_1,t_2)\)only depends on \(\Delta t = t_1 - t_2\) thus it could be written as \(U(t)\), and its motion of equation writes as:</p> \[i \hbar \frac{\partial}{\partial t} U(t) = \exp(\frac{i}{\hbar}H_0 t) H_1(t) \exp(-\frac{i}{\hbar}H t) = H_1^I(t) U(t),\] <p>By using the initial condition \(U(0) = 1\), the time evolution operator could be written as:</p> \[U(t) = 1 - \frac{i}{\hbar} \int_0^t \rm{d} t_1 H_1^I (t_1) U(t_1),\] <h2 id="tddft">TDDFT</h2> <h3 id="rouge-gross-theorem">Rouge-Gross Theorem</h3> <p>Rouge-Gross mapping:</p> <p>Considering two different external field, which differ by more than a purely time-dependent factor:</p> \[v_{\rm{ext}}' (\vec{r},t) \neq v_{\rm{ext}} (\vec{r},t) + c(t) \ \leftrightarrow \frac{\partial^k}{\partial^k t} [v_{\rm{ext}}' (\vec{r},t) - v_{\rm{ext}} (\vec{r},t)]|_{t=0}\] <p>The difference of a purely time-dependent factor means that all physical quantities are the same. Then think about the motion of equation for the current operator \(\hat{j} = \frac{1}{2i} \sum_{i} (\nabla_i \delta(\vec{r} - \vec{r}_i) + \delta (\vec{r} - \vec{r}_i) \nabla_i)\) at \(t=0\):</p> \[\begin{aligned} \frac{\partial}{\partial t} j(\vec{r},t) |_{t=0} &amp; = -i \langle \Psi_0 | [\hat{j}(\vec{r}), \hat{H}(\vec{r},0)] | \Psi_0 \rangle ,\\ &amp; = - n_0 (\vec{r}) \nabla v_{\rm{ext}} (\vec{r},0),\\ \end{aligned}\] <p>Then for two different \(v_{\rm{ext}}\):</p> \[\begin{aligned} \frac{\partial}{\partial t} [\vec{j}(\vec{r},t) - \vec{j}'(\vec{r},t)] |_{t=0} &amp; = -n_0 (\vec{r}) \nabla [ v_{\rm{ext}} (\vec{r},0) - v_{\rm{ext}}' (\vec{r},0) ], \\ &amp; = -n_0 (\vec{r}) \nabla w(\vec{r},0),\\ \end{aligned}\] <p>And r.h.s. doesn’t equal to zero if the difference is not a purely time-dependent factor, so as to the higher order derivatives:</p> \[\frac{\partial^{n+1}}{\partial t^{n+1}} [\vec{j}(\vec{r},t) - \vec{j}'(\vec{r},t)] |_{t=0} = - n_0 (\vec{r}) \nabla \frac{\partial^{n}}{\partial t^{n}} w(\vec{r},0) = - n_0 (\vec{r}) \nabla w_n(\vec{r},0),\] <p>And by using the continuity equation:</p> \[\frac{\partial }{\partial t} n(\vec{r},t) = - \nabla \cdot \vec{j} (\vec{r},t),\] <p>We reach the equation:</p> \[\frac{\partial^{n+2}}{\partial t^{n+2}} [n(\vec{r},t) - n'(\vec{r},t)] = - \nabla \cdot [n_0(\vec{r}) \nabla w_n(\vec{r},0) ],\] <p>The r.h.s. won’t equal to zero in most physical cases:</p> \[\int \rm{d} r w \nabla \cdot [n_0 \nabla w_n] = - \int \rm{d} r n_0 [\nabla w_n]^2 + \iint \rm{d} S \cdot [n_0 w_n \nabla w_n],\] <p>Where the surface integral vanishes because \(w_n \propto v_{\rm{ext}} \propto \frac{1}{r}\).</p> <p><strong>R-G mapping only suits for scalar potential, for electricmagnetic filed, TDCDFT is used.</strong></p> <h3 id="linear-response-theory">Linear Response Theory</h3> <h4 id="derivation-of-the-response-function">Derivation of the response function</h4> <p>The key method is to use the information of the unperturbed system to get the quantities under the perturbation. First, considering the states in Schrödinger picture, use \(\Psi'\) and \(\Psi\) to represent the states in the perturbed and unperturbed system:</p> \[\Psi' (t) = e^{-i H_0 t} A(t) \Psi(0), \ H = H_0 + H_1\] <p>By using \(i \frac{\partial}{\partial t} \Psi' (t) = H \Psi'(t)\) and \(i \frac{\partial}{\partial t} \Psi (t) = H_0 \Psi(t)\), we get the motion of equation for \(A(t)\):</p> \[\dot{A} = e^{i H_0 t} H_1(t) e^{-i H_0 t} A(t) = H_1^I (t) A(t), \ A(0) = 1,\] \[A(t) = 1 - i \int_{t_0}^t \rm{d} t' H_1^I(t') A(t') = 1 - i \int_{t_0}^t \rm{d} t' H_1^I(t') + \cdots,\] <p>Then the interaction wave function is (approximate to the first order):</p> \[\Psi'(t) = e^{-i H_0 (t-t_0)} \Psi(t_0) - i e^{-i H_0 (t-t_0)} \int_{t_0}^t \rm{d} t' H_1^I (t') \Psi(t_0),\] <p>Here \(t_0\) is the time when the perturbation is added, and we could take \(t_0 = 0\).</p> <p>Then for an abitrary operator \(\hat{O}\), the expectation value of the operator in the perturbed system is:</p> \[\begin{aligned} \langle O(t) \rangle &amp; = \langle \Psi'(t) | O^S | \Psi'(t) \rangle \\ &amp; = \langle \Psi(0) | (1 + i \int_0^t \rm{d} t' H_1^I (t') ) e^{i H_0 t} O^S e^{-iH_0 t} (1 - i \int_0^t \rm{d} t' H_1^I (t') ) | \Psi(0) \rangle \\ &amp; = \langle O(t) \rangle_{0} - i \int_0^t \rm{d} t' \langle [O(t) , H_1^I(t') ] \rangle_0 , \\ \end{aligned}\] <p>Where the subscript \(0\) means the expectation value in the unperturbed system, i.e. the expection value of wavefunction \(\Psi(0)\). Then the first-ordered response to the external perturbation is:</p> \[\begin{aligned} \delta \langle O(t) \rangle &amp; = \langle O(t) \rangle - \langle O(t) \rangle_0 \\ &amp; = - i \int_0^t \rm{d} t' \langle [O(t) , H_1^I(t') ] \rangle_0, \\ \end{aligned}\] <p>Now think about the response of the electron density to the external perturbation \(\delta v_{\rm{ext}}^I (t)\)，\(H_1^I(t) = \int \rm{d} r n^I(\vec{r},t) \delta v_{\rm{ext}} (\vec{r},t)\), so that:</p> \[\begin{aligned} \delta \langle n^I(\vec{r},t) \rangle &amp; = -i \int \rm{d} r' \int_{t_0}^{t} \rm{d} t' [n^I(\vec{r},t), n^I(\vec{r}',t')] \delta v_{\rm{ext}} (\vec{r}',t'), \\ &amp; = -i \int \rm{d} r' \int_0^{\infty} \theta (t - t') \rm{d} t' [n^I(\vec{r},t), n^I(\vec{r}',t')] \delta v_{\rm{ext}} (\vec{r}',t') \end{aligned}\] <p><strong>The integration of time starts from \(t_0\), and the Interaction picture is the same as the Heisenberg picture with no external pertubation.</strong></p> <h4 id="dyson-equation-of-response-function">Dyson equation of response function</h4> <p>Considering a sytem with time-dependent external perturbation \(\delta v_{\rm{ext}} (\vec{r},t)\), which is added at \(t=0\):</p> \[\delta v_{\rm{ext}} (\vec{r},t) = 0, \ \rm{for} \ t\leq 0 ,\] <p>And \(v_{\rm{ext}} (\vec{r},t) = v_{\rm{ext},0}(\vec{r}) + \delta v_{\rm{ext}} (\vec{r},t)\). Expand the electron density:</p> \[n(\vec{r},t) = n_0(\vec{r},t) + n_1(\vec{r},t) + n_2(\vec{r},t) + \cdots,\] <p>And to the first order, the response to the external perturbation is:</p> \[n_1 (\vec{r},t) = \int_0^{\infty} \rm{d} t' \int \rm{d}^3 r' \chi(\vec{r}t, \vec{r}'t') \delta v_{\rm{ext}} (\vec{r}',t'),\] <p>Where</p> \[\chi(\vec{r}t, \vec{r}'t') = -i \theta(t - t') \langle \Psi_0 | [\hat{n}_0(\vec{r},t) , \hat{n}_0(\vec{r'},t')] | \Psi_0 \rangle\] <p>By using \(n_0 (\vec{r},t) = e^{i H_0 t} n_0 (\vec{r}) e^{-i H_0 t}\), the Fourier transformation of the response function is:</p> \[\begin{aligned} \chi (\vec{r}, \vec{r}', \omega) &amp; = - i \sum_n \{ \int_0^{\infty} \rm{d} \tau e^{i \omega \tau} \langle \Psi_0 | n_0(\vec{r},t) | \Psi_n \rangle \langle \Psi_n | n_0(\vec{r}',t') | \Psi_0 \rangle - (\vec{r},t \leftrightarrow \vec{r}',t') \} ,\\ &amp; = - \sum_n \{ \int_0^{\infty} \rm{d} \tau e^{i \omega \tau} \langle \Psi_0 | e^{i \Omega_0 t} n_0(\vec{r}) e^{-i \Omega_n t} | \Psi_n \rangle \langle \Psi_n | e^{i \Omega_n t'} n_0(\vec{r}',t') e^{- i \Omega_0 t'} | \Psi_0 \rangle - (\vec{r},t \leftrightarrow \vec{r}',t') \} ,\\ &amp; = -i \sum_n \{ \int_0^{\infty} \rm{d} \tau e^{i \omega \tau} e^{ - i (\Omega_n - \Omega_0) \tau } \langle \Psi_0 | n_0(\vec{r},t) | \Psi_n \rangle \langle \Psi_n | n_0(\vec{r}',t') | \Psi_0 \rangle - (\vec{r},t \leftrightarrow \vec{r}',t') \} ,\\ &amp; = -i \sum_n \{ \int_{0}^{\infty} \rm{d} \tau e^{i (\omega + i 0^+) \tau} e^{ - i (\Omega_n - \Omega_0) \tau } \langle \Psi_0 | n_0(\vec{r},t) | \Psi_n \rangle \langle \Psi_n | n_0(\vec{r}',t') | \Psi_0 \rangle - (\vec{r},t \leftrightarrow \vec{r}',t') \} ,\\ &amp; = \sum_n [\frac{ \langle \Psi_0 | \hat{n}(\vec{r}) | \Psi_n \rangle \langle \Psi_n | \hat{n} (\vec{r}') | \Psi_0 \rangle }{\omega - (\Omega_n - \Omega_0) + i 0^+ } - \frac{ \langle \Psi_0 | \hat{n}(\vec{r}') | \Psi_n \rangle \langle \Psi_n | \hat{n} (\vec{r}) | \Psi_0 \rangle }{\omega + (\Omega_n - \Omega_0) + i 0^+ } ] ,\\ \end{aligned}\] <p>Here \(i 0^+\) is used to refine the integral, to let the integral vanish at \(t \rightarrow \infty\), and to force the contour line located in upper area so that \(\tau \geq 0\) when transform to time domain \(\int \rm{d} \tau e^{-i \omega \tau} \chi (\vec{r}', \vec{r}, \omega)\).</p> \[[- \frac{\nabla^2}{2} + \int \rm{d} r' \frac{n(\vec{r}',t)}{|\vec{r} - \vec{r}'|} + v_{\rm{ext},0}(\vec{r}) + v_{\rm{xc}}(\vec{r},t)] \Psi_n = \Omega_n \Psi_n\] <p>Actually, it’s difficult to get \(\chi\) directly, <strong>because all they are all interaction states, and we don’t now its specific form. The “unpertubation states” in this case is the system withot \(\delta v_{\rm{ext}}\), that means other terms, such as \(v_{\rm{xc}}, \ n\) are still time-dependent.</strong> We could turn to the Kohn-Sham system, which is a non-interaction system, and for Kohn-Sham system, it’s easily to get the response function:</p> \[n_1 (\vec{r},t) = \int_0^{\infty} \rm{d} t' \int \rm{d} r' \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') \delta v_{\rm{KS}} (\vec{r}',t'),\] <p>So all the vairiation that contains time are all packed into \(\delta v_{\rm{KS}}\), and the original states does not depend on time, so as to the wavefuctions, they are just the eigenstates of the Kohn-Sham Hamiltonian.</p> \[[- \frac{\nabla^2}{2} + \int \rm{d} r' \frac{n(\vec{r}')}{|\vec{r} - \vec{r}'|} + v_{\rm{ext},0}(\vec{r}) + v_{\rm{xc}}(\vec{r})] \psi_j = \epsilon_j \psi_j\] <p>It’s easy to get the response function of Kohn-Sham system:</p> \[\begin{aligned} \chi_{\rm{KS}} (\vec{r}, \vec{r}, \omega) &amp; = \sum_k f_{k} \sum_j [ \frac{ \langle \psi_k | \hat{n}(\vec{r}) | \psi_j \rangle \langle \psi_j | \hat{n} (\vec{r}') | \psi_k \rangle }{ \omega - (\epsilon_j - \epsilon_k) + i 0^+ } - \frac{ \langle \psi_k | \hat{n}(\vec{r}') | \psi_j \rangle \langle \psi_j | \hat{n} (\vec{r}) | \psi_k \rangle }{ \omega + (\epsilon_j - \epsilon_k) + i 0^+ } ] ,\\ &amp; = \sum_{jk} [ f_k \frac{ \langle \psi_k | \hat{n}(\vec{r}) | \psi_j \rangle \langle \psi_j | \hat{n} (\vec{r}') | \psi_k \rangle }{ \omega - (\epsilon_j - \epsilon_k) + i 0^+ } - f_j \frac{ \langle \psi_j | \hat{n}(\vec{r}') | \psi_k \rangle \langle \psi_k | \hat{n} (\vec{r}) | \psi_j \rangle }{ \omega - (\epsilon_j - \epsilon_k) + i 0^+ } ] ,\\ &amp; = \sum_{jk} (f_k - f_j) \frac{ \psi_k^* (\vec{r}) \psi_j (\vec{r}) \psi_j^* (\vec{r}') \psi_k (\vec{r'}) }{ \omega + (\epsilon_j - \epsilon_k) + i 0^+ } ,\\ \end{aligned}\] <p>Where we use the defination for number operator \(\hat{n} (\vec{r}) = \sum_j \delta (\vec{r} - \vec{r}_j)\). The index “j” is exact the particles corresponding to eigenstaes \(\psi_j\) in K-S equation, and <strong>the expection is taken in all particles thus there’s a sum over j and additional occupied number \(f_j\)</strong>.</p> <p>The \(v_{\rm{KS}}\) contains \(v_{\rm{ext}}\) and for their first order pertubation:</p> \[\begin{aligned} \delta v_{\rm{KS}} (\vec{r},t) &amp; = \delta v_{\rm{ext}} (\vec{r},t) + \int \rm{d} r' \frac{n_1(\vec{r}',t)}{|r-r'|} + v_{\rm{xc}}(\vec{r},t), \\ &amp; = \delta v_{\rm{ext}} (\vec{r},t) + \int \rm{d} r' \frac{n_1(\vec{r}',t)}{|r-r'|} + \int \rm{d} t' \int \rm{d}r' f_{\rm{xc}}(\vec{r}t, \vec{r}'t') n_1(\vec{r}',t'), \end{aligned}\] <p>Here \(f_{\rm{xc}}\) is the exchange-correlation kernel. Then substitute the expression of \(\delta v_{\rm{KS}}\) into the response function, we get the Dyson equation of the response function:</p> \[\begin{aligned} \int_0^{\infty} \rm{d} t' \int \rm{d} r' \chi (\vec{r}t, \vec{r}'t') \delta v_{\rm{ext}} (\vec{r}',t') &amp; = \int_0^{\infty} \rm{d} t' \int \rm{d} r' \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') \delta v_{\rm{KS}} (\vec{r}',t'), \\ &amp; = \int_0^{\infty} \rm{d} t' \int \rm{d} r' \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') \delta v_{\rm{ext}} (\vec{r}',t') + \int_0^{\infty} \rm{d} t' \int \rm{d} r' \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') \int \rm{d} r'' \frac{n_1(\vec{r}'',t')}{|r'-r''|} \\ &amp; + \int \rm{d} t' \int \rm{d} r'' \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') \int \rm{d} t'' \int \rm{d} r'' f_{\rm{xc}}(\vec{r}'t', \vec{r}''t'') n_1(\vec{r}'',t''), \\ \end{aligned}\] <p>And \(n_1\) in the last two terms in r.h.s. could be written as the response to \(\delta v_{\rm{ext}}\), so that:</p> \[\begin{aligned} \chi (\vec{r}t,\vec{r}'t') &amp; = \chi_{\rm{KS}} (\vec{r}t,\vec{r}'t') + \int \rm{d} t_1 \int \rm{d} r_1 \int \rm{d} r_2 \chi_{\rm{KS}} (\vec{r}t, \vec{r}_1 t_1) \frac{1}{|r_1 - r_2|} \chi (\vec{r}_2 t_1, \vec{r}t) \\ &amp; + \int \rm{d} t_1 \int \rm{d} t_2 \int \rm{d} r_1 \int \rm{d} r_2 \chi_{\rm{KS}} (\vec{r}t, \vec{r}_1 t_1) f_{\rm{xc}} (\vec{r}_1 t_1,\vec{r}_2,t_2) \chi (\vec{r}_2 t_2, \vec{r}' t'' ) ,\\ &amp; = \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') + \int \rm{d} t_1 \int \rm{d} t_2 \int \rm{d} r_1 \int \rm{d} r_2 \chi_{\rm{KS}} (\vec{r} t, \vec{r}_1 t_1) f_{\rm{Hxc}} (\vec{r}_1 t_1, \vec{r}_2 t_2) \chi (\vec{r}_2 t_2, \vec{r}' t'),\\ \end{aligned}\] <p>And</p> \[f_{\rm{Hxc}} (\vec{r}_1 t_1, \vec{r}_2 t_2) = \frac{\delta (t_1 - t_2)}{| r_1 - r_2|} + f_{\rm{xc}} (\vec{r}_1 t_1, \vec{r}_2 t_2)\] <p>The are all functions to the density of ground state \(n_{\rm{GS}}\).</p> <h4 id="dyson-equation-of-response-function-functional-derivative">Dyson equation of response function (functional derivative)</h4> <p><a class="citation" href="#Gross1996">(Petersilka et al., 1996)</a> are the main reference for this part. First, considering the defination of the response function:</p> \[n_1 (\vec{r}, t ) = \int \rm{d} t' \int \rm{d} r' \chi (\vec{r}t, \vec{r}'t') \delta v_{\rm{ext}} (\vec{r}',t'),\] <p>So that \(\chi (\vec{r} t, \vec{r}' t') = \frac{ \delta n_1 (\vec{r}, t) }{ \delta v_{\rm{ext}} (\vec{r}' ,t') }\), and by using the chain rule:</p> \[\chi (\vec{r} t, \vec{r}' t') = \int \rm{d} t_1 \int \rm{d} r_1 \frac{ \delta n_1 (\vec{r}, t) }{ \delta v_{\rm{KS}} (\vec{r}_1 ,t_1) } \frac{ \delta v_{\rm{KS}} (\vec{r}_1,t_1) }{ \delta v_{\rm{ext}} (\vec{r}' ,t') },\] <p>Where \(v_{\rm{KS}} (\rm{r}, t) = v_{\rm{ext}} (\vec{r}, t) + v_{\rm{H}} (\vec{r}, t) + v_{\rm{xc}} (\vec{r},t), \ v_{\rm{H}} (\vec{r},t) = \int \rm{d} r' \frac{n(\vec{r'}, t)}{ r -r' }\). Defining the xc kernal by \(f_{\rm{xc}} (\vec{r}t, \vec{r}'t') = \frac{\delta v_{\rm{xc}} (\vec{r},t) }{ \delta n_1 (\vec{r}',t') }\), then:</p> \[\begin{aligned} \chi (\vec{r} t, \vec{r}' t') &amp; = \int \rm{d} t_1 \int \rm{d} r_1 \frac{ \delta n_1 (\vec{r}, t) }{ \delta v_{\rm{KS}} (\vec{r}_1 ,t_1) } \frac{ \delta v_{\rm{KS}} (\vec{r}_1,t_1) }{ \delta v_{\rm{ext}} (\vec{r}' ,t') }, \\ &amp; = \int \rm{d} t_1 \int \rm{d} r_1 \frac{ \delta n_1 (\vec{r}, t) }{ \delta v_{\rm{KS}} (\vec{r}_1 ,t_1) } ( \frac{ \delta v_{\rm{ext}} (\vec{r}_1,t_1) }{ \delta v_{\rm{ext}} (\vec{r}' ,t') } + \frac{ \delta v_{\rm{H}} (\vec{r}_1,t_1) }{ \delta v_{\rm{ext}} (\vec{r}' ,t') } + \frac{ \delta v_{\rm{xc}} (\vec{r}_1,t_1) }{ \delta v_{\rm{ext}} (\vec{r}' ,t') } ) ,\\ &amp; = \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') + \int \rm{d} t_1 \int \rm{d} t_2 \int \rm{d} r_1 \int \rm{d} r_2 ( \frac{ \delta v_{\rm{H}} (\vec{r}_1 , t_1) }{ \delta n_1 (\vec{r}_2, t_2) } \frac{ n_1 (\vec{r}_2 , t_2 ) }{ \delta v_{\rm{ext}} (\vec{r}', t') } + \frac{ \delta v_{\rm{xc}} (\vec{r}_1 , t_1) }{ \delta n_1 (\vec{r}_2, t_2) } \frac{ n_1 (\vec{r}_2 , t_2 ) }{ \delta v_{\rm{ext}} (\vec{r}', t') } ) ,\\ &amp; = \chi_{\rm{KS}} (\vec{r}t, \vec{r}'t') + \int \rm{d} t_1 \int \rm{d} t_2 \int \rm{d} r_1 \int \rm{d} r_2 ( \frac{ \delta (t_1 - t_2) }{ | r_1 - r_2 | } + f_{\rm{xc}} (\vec{r}_1 t_1, \vec{r}_2 t_2) ) \chi (\vec{r}_2 t_2, \vec{r}' t') ,\\ \end{aligned}\] <h4 id="excitation-energies-and-oscillator-strength">Excitation energies and oscillator strength</h4> <p>The excitation energies are the poles of the response function \(\chi\), and by using Dyson equation of the response function, we could get the excitation energies of the system.</p> \[\chi (\omega) = \chi_{\rm{KS}} (\omega) + \chi_{\rm{KS}} (\omega) \cdot f_{\rm{Hxc}} (\omega) \cdot \chi (\omega),\] \[( \hat{1} - \chi_{\rm{KS}} (\omega) \cdot f_{\rm{Hxc}} (\omega) ) \cdot \chi (\omega) = \chi_{\rm{KS}} (\omega),\] <p>Here we use the matrix form of the response function, in \((\vec{r} t,\vec{r}' t')\) space. And the poles of \(\chi\) satisfy the equation:</p> \[\hat{1} - \chi_{\rm{KS}} (\omega) \cdot f_{\rm{Hxc}} (\omega) = 0 \leftrightarrow \chi_{\rm{KS}} (\omega) \cdot f_{\rm{Hxc}} (\omega) \cdot \xi (\omega) = \lambda (\omega) \xi(\omega),\] <p>Here \(\lambda(\Omega) = 1\), it equals to 1 at the real excitation energies. Then using transition representation:</p> \[\begin{aligned} &amp; f_q = f_k - f_j , \ f_{-q} = - f_q,\\ &amp; \omega_q = \epsilon_j- \epsilon_k, \ \omega_{-q} = - \omega_q, \\ &amp; \Phi_q = \psi_k^* \psi_j, \ \Phi_{-q} = \Phi_q^*, \\ &amp; \chi_{\rm{KS}} (\omega) = \sum_q f_q \frac{\Phi_q^* \Phi_q}{\omega - \omega_q + i 0^+}, \\ &amp; \zeta_q (\omega) = \Phi_q^* \cdot f_{\rm{Hxc}} \cdot \xi ,\\ \end{aligned}\] <p>We have the equation:</p> \[\sum_{q'} \frac{M_{qq'}}{\omega - \omega_{q'} + i 0^+} \zeta_q' (\omega) = \lambda (\omega) \zeta_q (\omega),\] <p>Where \(M_{qq'} = f_q' \Phi_q \cdot f_{\rm{Hxc}} \cdot \Phi_{q'}\). And if we seperate \(\zeta_q\) into q and -q terms and denotes them as \(X_q, \ Y_{-q}, \ q \geq 0\) respectively, we know that \(Y_{-q}^* = X_q\), this is the common representation in many books. And for the excitation energies \(\omega = \Omega\), \(\lambda(\Omega) = 1\) then the equation becomes:</p> \[\sum_{q'} (M_{qq'} + \omega_q \delta_{qq'}) \beta_{q'} = \Omega \beta_q, \ \beta_q = \frac{\zeta_q}{\Omega - \omega_q},\] \[\begin{aligned} &amp; q \geq 0: \ \sum_{q' \geq 0} (M_{qq'} + \omega_q \delta_{qq'}) \beta_{q'} + \sum_{q'&lt;0} M_{q,-|q'|} \beta_{-|q'|} = \Omega \beta_q ,\\ &amp; q &lt; 0: \ \sum_{q'\geq 0} M_{-|q|,q'} \beta_{q'} + \sum_{q' &lt; 0} (M_{-|q|,-|q|'} - \omega_|q| \delta_{qq'}) \beta_{-|q|'} = \Omega \beta_q ,\\ \end{aligned}\] \[\begin{pmatrix} A &amp; B \\ B^* &amp; A^* \\ \end{pmatrix} \begin{pmatrix} X \\ Y \\ \end{pmatrix} = \Omega \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; -1 \\ \end{pmatrix} \begin{pmatrix} X \\ Y \\ \end{pmatrix}\] <p>Here,</p> \[\begin{aligned} &amp; A_{qq'} = M_{qq'} + \omega_q \delta_{qq'}, \ q,q' \geq 0,\\ &amp; B_{qq'} = M_{q,-q'}, \ q ,q' \geq 0,\\ \end{aligned}\] <p><strong>\(\omega_q^* = \omega_q\), then \(A_{qq'}^* = M_{-q,-q'} + \omega_q \delta_{qq'}\).</strong></p> <h5 id="approximate-solution">Approximate solution</h5> <p>There are two kind of approximation, single-pole approximation(SPA) and small matrix approximation(SMA). In SPA, \(\chi_{\rm{KS}}\) is expand at the pole \(\omega_q\), \(\chi_{\rm{KS}} = f_q \frac{\Phi_q^* (\vec{r}') \Phi_q (\vec{r})}{\omega - \omega_q + i 0^+}\). It’s the same to only take the diagonal elements of matrix \(A\).</p> <p>And SMA also contains the backforward transition, i.e. the -q terms, \(\chi_{\rm{KS}} = f_q \frac{\Phi_q^* (\vec{r}') \Phi_q (\vec{r})}{\omega - \omega_q + i 0^+} - f_q \frac{\Phi_q^* (\vec{r}) \Phi_q (\vec{r}')}{\omega + \omega_q + i 0^+}\). It’s the same to take the diagonal elements for the whole matrix \(M\).</p>]]></content><author><name></name></author><category term="Physics"/><category term="Quantum mechanics"/><summary type="html"><![CDATA[Basic pictures in Schrödinger equation]]></summary></entry><entry><title type="html">Notes for gimic</title><link href="https://liangguangyii.github.io/blog/2024/notes-for-gimic/" rel="alternate" type="text/html" title="Notes for gimic"/><published>2024-02-13T21:01:00+00:00</published><updated>2024-02-13T21:01:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-for-gimic</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-for-gimic/"><![CDATA[<p>Basic introduction and usage could be found in <a href="http://sobereva.com/491">Tian Lu’s blog</a>, or <a href="https://github.com/qmcurrents/gimic/tree/master/doc">the document of gimic</a></p> <h2 id="installation">Installation</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./setup <span class="nt">--omp</span>
<span class="nb">cd </span>build
make <span class="nb">install</span>
</code></pre></div></div> <p>If executable file setup runs successfully, then <code class="language-plaintext highlighter-rouge">build</code> directory will be created. And to restart, <code class="language-plaintext highlighter-rouge">build</code> should be removed.</p> <p>And there are some fucking bugs in the python part of source code, in <code class="language-plaintext highlighter-rouge">src/pygimic</code>, for the <code class="language-plaintext highlighter-rouge">connector.pxd</code> and <code class="language-plaintext highlighter-rouge">connector.pyx</code> (the cpython code).</p> <p>The reason has found, which is the duplicate definition of function <code class="language-plaintext highlighter-rouge">GimicConnector</code>. It has already defined in <code class="language-plaintext highlighter-rouge">connector.pyx</code>, and decalared in <code class="language-plaintext highlighter-rouge">connector.pxd</code>, so it’s unnecessary to <code class="language-plaintext highlighter-rouge">cimport</code> in once again from pxd doc.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Generic GIMIC interface
#
# Jonas Juselius &lt;jonas.juselius@uit.no&gt; 2012
#
</span>
<span class="kn">from</span> <span class="n">pygimic.gimic_exceptions</span> <span class="kn">import</span> <span class="n">NotAvailable</span>
<span class="c1">#NO NEEDED!
#from connector cimport GimicConnector
</span>
<span class="n">cdef</span> <span class="k">class</span> <span class="nc">GimicConnector</span><span class="p">:</span>
    <span class="n">cpdef</span> <span class="nf">jvector</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotAvailable</span><span class="p">(</span><span class="sh">'</span><span class="s">jvector()</span><span class="sh">'</span><span class="p">)</span>

    <span class="n">cpdef</span> <span class="nf">jtensor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotAvailable</span><span class="p">(</span><span class="sh">'</span><span class="s">jtensor()</span><span class="sh">'</span><span class="p">)</span>

    <span class="n">cpdef</span> <span class="nf">set_property</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nc">GimicConnector</span><span class="p">()</span>
    <span class="n">g</span><span class="p">.</span><span class="nf">jvector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># vim:et:ts=4:
</span></code></pre></div></div> <h2 id="usage">Usage</h2> <h3 id="gaussian-output-file">Gaussian output file</h3> <p>There are two cases: closed shell and open shell. Both of them should add the keyword <code class="language-plaintext highlighter-rouge">pop=full Int=NoBasisTransform IOp(10/33=2)</code> in NMR(GIAO) calculation, for the information transformation from different software (IOp(10/33=2) to print the perturbed density matrices in the output file).</p> <p>And two files named <code class="language-plaintext highlighter-rouge">Gaussian2gimic.py</code> and <code class="language-plaintext highlighter-rouge">BasisSet.py</code> in <code class="language-plaintext highlighter-rouge">gimic/tools/g092gimic</code> should be used to generated <code class="language-plaintext highlighter-rouge">XDENS</code> and <code class="language-plaintext highlighter-rouge">MOL</code>.</p> <p>For closed shell, fchk files are needed, then <code class="language-plaintext highlighter-rouge">./Gaussian2gimic.py --input=test.fchk</code>.</p> <p>For open shell, log files are needed, so extra keyword <code class="language-plaintext highlighter-rouge">gfprint</code> should be added in the input file, to print the basis set information, then <code class="language-plaintext highlighter-rouge">./Gaussian2gimic.py --input=test.log</code>.</p> <p>And the calculation is proceeded in a cubic box, so the initial orientation of the molecule should be considered, by using <code class="language-plaintext highlighter-rouge">nosymm</code> keyword.</p> <h3 id="cdens-calculation">cdens calculation</h3> <p>Output files:</p> <p><code class="language-plaintext highlighter-rouge">mol.xyz</code>: the coordinates of the molecule</p> <p><code class="language-plaintext highlighter-rouge">grid.xyz</code>: the coordinates of the molecule, together with eight atoms around the molecule, to form a cubic box</p> <p><code class="language-plaintext highlighter-rouge">acid.vti</code>: the grids data of <a href="http://sobereva.com/147">acid function</a>.</p> <p><code class="language-plaintext highlighter-rouge">jmod.vti</code>: the norm of the current density.</p> <p><code class="language-plaintext highlighter-rouge">jvec.vti</code>: the current density vector.</p> <p>To export the data to paraView, cml format file should be used instead of xyz format. And the unit of cml should be in Bohr, while <code class="language-plaintext highlighter-rouge">mol.xyz</code> is in Angstrom. <strong>Then the <code class="language-plaintext highlighter-rouge">mol.xyz</code> should be converted to Bohr, by multiplying 1.889725989, or divided by 0.5291772109.</strong> The script is as follows, openbabel should be installed first:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>obabel <span class="nt">-ixyz</span> mol.xyz <span class="nt">-ocml</span> <span class="nt">-O</span> mol.cml
<span class="nb">awk</span> <span class="s1">'{ {FS="\""}; {OFS="\""};
     if ($1 ~ "&lt;atom id") {
         if ($5 ~ "spinMultiplicity")
             { print $1, $2, $3, $4, $5, $6, $7, $8/0.529177, $9, $10/0.529177, $11, $12/0.529177, $13 }
         else if ($5 ~ "hydrogenCount")
             { print $1, $2, $3, $4, $5, $6, $7, $8/0.529177, $9, $10/0.529177, $11, $12/0.529177, $13 }		 
     	 else  { print $1, $2, $3, $4, $5, $6/0.529177, $7, $8/0.529177, $9, $10/0.529177, $11 }
         }
     else print $0; }'</span> mol.cml <span class="o">&gt;</span> mol-bohr.cml

</code></pre></div></div> <h3 id="integral-calculation">integral calculation</h3> <p>Generate grids perpendicularly to the <code class="language-plaintext highlighter-rouge">bond</code>/<code class="language-plaintext highlighter-rouge">line</code>, then fix its orientation, by using <code class="language-plaintext highlighter-rouge">fixpoint</code>/<code class="language-plaintext highlighter-rouge">fixcoord</code>, all length should be in Bohr.</p> <p>1. <code class="language-plaintext highlighter-rouge">bond = [a, b]</code> + <code class="language-plaintext highlighter-rouge">distance</code> + <code class="language-plaintext highlighter-rouge">fixpoint</code> + <code class="language-plaintext highlighter-rouge">height[-down, up]</code> + <code class="language-plaintext highlighter-rouge">width[-in, out]</code></p> <p>2. <code class="language-plaintext highlighter-rouge">coord1</code> + <code class="language-plaintext highlighter-rouge">coord2</code> + <code class="language-plaintext highlighter-rouge">distance</code> + <code class="language-plaintext highlighter-rouge">fixcoord</code> + <code class="language-plaintext highlighter-rouge">height[-down, up]</code> + <code class="language-plaintext highlighter-rouge">width[-in, out]</code></p> <p>In integral calculation, <code class="language-plaintext highlighter-rouge">bond</code> in <code class="language-plaintext highlighter-rouge">Grid</code> function is used to generate the plane grid. <a href="https://github.com/qmcurrents/gimic/blob/master/doc/grids.rst">The ’bond’ type grids define a plane through a bond, or any other defined vector. The plane is orthogonal to the vector defining the bond.</a> To fix the orientation of the plane(or it will rotate along the bond), <code class="language-plaintext highlighter-rouge">fixpoint</code>/<code class="language-plaintext highlighter-rouge">fixcoord</code> is needed, the line of rectangle should be parallel to the projection of the vector connecting rotation axis of plane and fixpoint onto the plane.</p> <p><strong>The positive direction of <code class="language-plaintext highlighter-rouge">bond</code> grids (a,b) is the current from b to a.</strong></p> <p>Figure following shows the plane grids under parameters: v</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calc=integral          # cdens, integral
basis="../MOL"
xdens="../XDENS"
openshell=false
magnet=[0,0,1]

Grid(bond) {
    type=gauss                  # Gauss distribution of grid points
    gauss_order=9               # order for gauss quadrature
   bond=[1,2]                  # Use two atoms to define the direction
#   coord1=[-1.21, 0.699, 0.0] # Use two points to define the direction, Bohr
#   coord2=[-1.21, -0.699, 0.0]
    distance=1.32               # Distance of the plane to the first point, Bohr
#   fixpoint=4
   fixcoord=[1.0, 0.0, 1.0]
    grid_points=[30, 30, 0]     # Number of points on grid (i,j,k)
    height=[-5.0, 5.0]    # Grid size of height relative to grid center
    width=[-2.2, 5.0]     # Grid size of width relative to grid center
}

Advanced {
    lip_order=5      # order of Lagrange Interpolating Polynominals to use
    spherical=off     # don't touch, unless you REALLY know what you are doing
    diamag=on           # turn on/off diamagnetic contributions
    paramag=on          # turn on/off paramagnetic contributions
}
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/blog/gimic/gimic_plane1-480.webp 480w, /assets/img/blog/gimic/gimic_plane1-800.webp 800w, /assets/img/blog/gimic/gimic_plane1-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/gimic/gimic_plane1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img//blog/gimic/benzene-plane-documentation-480.webp 480w, /assets/img//blog/gimic/benzene-plane-documentation-800.webp 800w, /assets/img//blog/gimic/benzene-plane-documentation-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img//blog/gimic/benzene-plane-documentation.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The plane grids under parameters. </div>]]></content><author><name></name></author><category term="DFT"/><category term="gimic"/><category term="DFT"/><summary type="html"><![CDATA[Basic introduction and usage could be found in Tian Lu’s blog, or the document of gimic]]></summary></entry><entry><title type="html">Persistent current in 1-D ring</title><link href="https://liangguangyii.github.io/blog/2024/notes-phy-persistent-current/" rel="alternate" type="text/html" title="Persistent current in 1-D ring"/><published>2024-02-13T21:01:00+00:00</published><updated>2024-02-13T21:01:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-phy-persistent-current</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-phy-persistent-current/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Persistent current in 1D ring has been a hot topic during last centery. Especially for its current direction, which is sensitive to the number of electrons in the ring.</p> <h2 id="eigenstates-and-energy">Eigenstates and energy</h2> <p>The 1D ring is shown as follows, with the radius \(R\) and circumference \(L\).</p> <script type="text/tikz">
\begin{tikzpicture}
    \fill[white] (-2.5,-2.5) rectangle (2.5,2.5);

    \draw (0,0) circle(2.0);
    \draw [->] (0,0) -- (1.0,1.732);
    \node at (0.5,0.4) {$R$};
\end{tikzpicture}
</script> <p>Then turn to the cylindrical coordinate system, for which the gradient are given as:</p> \[\nabla = \frac{1}{r} \frac{ \partial}{ \partial \theta} \rm{d} \vec{ \theta} + \frac{ \partial }{ \partial r} \rm{d} \vec{r} + \frac{ \partial}{ \partial z} \rm{d} \vec{z}\] <p>And for 1D ring, \(r\) is a constant \(r = R\), then</p> \[\nabla = \frac{1}{R} \frac{ \partial}{ \partial \theta} \rm{d} \vec{ \theta} = \frac{1}{R} \frac{ \partial}{ \partial u} \rm{d} \vec{u} = \frac{ \partial }{ \partial u} \rm{d} \vec{\hat{u}}\] <p>where \(u = \theta R\), and unit base vector \(\vec{\hat{u}} = \frac{1}{R} \vec{u}\) should be taken.</p> <p>The Hamiltonian of a single electron under electromagnetic field is given as:</p> \[H = \frac{1}{2 m} ( \vec{p} + e \vec{A} )^{2} - e \Phi\] <p>Here \(e\) is the absolute value of electron charge, and we take the speed of light \(c = 1\), \(\Phi\) is the scalar potential, and \(\vec{A}\) is the vector potential. \(\Phi=0\) when only take magnetic field into account.</p> <p>For the relationship between vector potential and magnetic flux, we have:</p> \[\iint \rm{d} S \cdot \vec{B} = \iint \rm{d} S \cdot ( \nabla \times \vec{A} ) = \iint \rm{d} l \cdot \vec{A}\] <p>Which means \(\phi = A \cdot L\). Then rewrite the Hamiltonian:</p> \[H = \frac{1}{2m}(-i \hbar \frac{ \partial}{ \partial u} + e \frac{ \phi}{ L})^{2} = \frac{h^2}{2mL^2} ( - i R \frac{ \partial}{ \partial u} + \frac{ \phi}{ {\phi}_{0}})^2\] <p>And \(\phi_{0} = \frac{h}{e}\) is the magnetic flux quantum. The boundary condition in this gauge is \(\psi(u + L) = \psi(u)\)， assume \(\psi(u) \propto e^{i X u}\), then \(XL = 2 n \pi, \ n \in Z\). Then the wave function and the corresponding energy is:</p> \[\psi(u) = \frac{1}{ \sqrt{L} } \exp(i \frac{2n \pi u}{L}),\] \[{ \epsilon}_{n} = \frac{h^2}{2mL^2} ( \frac{1}{L} 2n \pi R + \frac{\phi}{\phi_0})^2 = \frac{h^2}{2mL^2} ( n + \frac{\phi}{\phi_0})^2\] <p>We can see that the energy is periodic with \(\frac{\phi}{\phi_0}\), as shown as follows:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/blog/1Dring/energy1D-480.webp 480w, /assets/img/blog/1Dring/energy1D-800.webp 800w, /assets/img/blog/1Dring/energy1D-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/1Dring/energy1D.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The energy bands of 1D ring. </div> <h3 id="gauge-transformation">Gauge transformation</h3> <p>The vector potential \(\vec{A}\) is not unique \(\vec{A}' = \vec{A} + \nabla \Lambda\), we can say \(\vec{A}'\) is in the different gauge. All the physical quantities are gauge invariant, though the Schrödinger equation and the boundary condition are not, that means we could choose the gauge to simplify the calculation.</p> \[\nabla \Lambda = - \vec{A}\] \[\Lambda = - \int_{r_0}^{r} \rm{d} r' \vec{A} (r') = - \iint \rm{d} S \cdot (\nabla \times \vec{A}) = - \phi\] <p>Under the gauge tansformation there is:</p> \[(\vec{p} + e \vec{A}) e^{ - i \frac{ e \Lambda}{ \hbar}} = e^{ - i \frac{ e \vec{A}}{ \hbar}} \vec{p}, \ \nabla \Lambda = \vec{A}\] <p>And the wave function in the new gauge is \(\psi'(u) = e^{ - 2 \pi i \frac{ \Lambda}{ \phi_0}} \psi(u)\). The boundary condition writes as:</p> \[\psi'(u+L) = e^{ - 2 \pi i \frac{ \Lambda(r + L)}{ \phi_0}} \psi(u) = e^{ - 2 \pi i \frac{ \Lambda(r + L) - \Lambda(r)}{ \phi_0}} \psi(u) = \exp(2 \pi i \frac{\phi}{\phi_0}) \psi'(u)\] <p>With Hamiltonian \(H' = \frac{h^2}{2mL^2} (-iR \frac{\partial }{ \partial u })^2\).</p> <h2 id="persistent-current">Persistent current</h2> <p>The expectation value of current is given as:</p> \[\vec{j} = \rm{Re} ( \psi^* \vec{v} \psi ), \ \vec{v} = - \frac{1}{m} (\vec{p} + e \vec{A})\] <p>Because \(H = \frac{1}{2} m v^2, \ \frac{\partial}{\partial \phi} H = - \frac{e}{L} v\), then \(j_{n} = - \frac{\partial}{\partial \phi} \epsilon_n = - \frac{eh}{mL^2} (n + \frac{\phi}{\phi_0})\). The total current is:</p> \[I = \sum_n i_n f(\epsilon, \mu, T) = - \sum_n \frac{ \partial }{ \partial \phi } \epsilon_n (1 + \exp( - \frac{\mu - \epsilon_n}{k_{B} T}))^{-1} = - \frac{\partial \Omega}{\partial \phi}\] \[\Omega = -k_{B} T \sum_n \ln(1 + \exp(- \frac{\mu - \epsilon_n}{k_{B} T}) )\] <p>We only consider the area between \(-\frac{1}{2} \phi_0\) to \(\frac{1}{2} \phi_0\) due to the periodicity of the system with magnetic flux. The arrangement of the energy levels are different for different cases of magnetic flux, while there still exist couples that will cancel each other, the \(2n+1\) and \(2n+2\) couple(\(n&gt;0\)), \(i_{2n+1} + i_{2n+2} = - \frac{2eh}{mL^2} \frac{\phi}{\phi_0}\). When the total electron number \(N = 4n+2\)(spin degeneracy considered):</p> \[I_{4n+2} = -\frac{eh}{mL^2}(4n+2) \frac{\phi}{\phi_0}\] <p>The contribution of the next three electrons are:</p> \[\delta I=\frac{eh}{mL^2} (\rm{sgn}(\phi) N - \frac{\phi}{\phi_0} ), \ N=4n + 3\] \[\delta I=\frac{eh}{mL^2} (\rm{sgn}(\phi) N - \frac{\phi}{\phi_0} ), \ N=4n + 4\] \[\delta I=\frac{eh}{mL^2} (- \rm{sgn}(\phi) N - \frac{\phi}{\phi_0} ), \ N=4n + 5\]]]></content><author><name></name></author><category term="Physics"/><category term="Quantum mechanics"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Tips for Gaussian</title><link href="https://liangguangyii.github.io/blog/2024/note-for-gaussian/" rel="alternate" type="text/html" title="Tips for Gaussian"/><published>2024-02-13T00:00:00+00:00</published><updated>2024-02-13T00:00:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/note-for-gaussian</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/note-for-gaussian/"><![CDATA[<h2 id="input-format">Input format</h2> <p>Input format is different between Windows and linux. the blank line number is different.0</p> <h2 id="the-structure-of-shell-and-basis-function-for-gtf-in-fch-file">The structure of shell and basis function for gtf in fch file</h2> <h3 id="shell-type"><code class="language-plaintext highlighter-rouge">Shell type</code>:</h3> <ul> <li>-4: 9g</li> <li>-3: 7f</li> <li>-2: 5d</li> <li>-1: sp</li> <li>0: 1s</li> <li>1: 3p</li> <li>2: 6d</li> <li>3: 10f</li> <li>4: 15g</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Shell types                                I   N=          13
           0          -1          -1           2           0           0
           1           0           0           1           0           0
           1
</code></pre></div></div> <h3 id="number-of-primitives-per-shell"><code class="language-plaintext highlighter-rouge">Number of primitives per shell</code>:</h3> <p>The contraction number of each shell, the number of elements of primitives per shell equals to the number of shell types.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Number of primitives per shell             I   N=          13
           6           3           1           1           3           1
           1           3           1           1           3           1
           1
</code></pre></div></div> <h3 id="primitive-exponents-and-contraction-coefficients"><code class="language-plaintext highlighter-rouge">Primitive exponents</code> and <code class="language-plaintext highlighter-rouge">Contraction coefficients</code>:</h3> <p>They are the same of every compenents for the same shell type, i.e. the same for the X Y Z components of the shell type <code class="language-plaintext highlighter-rouge">1</code>, then its element number is equal to the sum of each contraction number of the corresponding shell.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Primitive exponents                        R   N=          26
  3.04752488E+03  4.57369518E+02  1.03948685E+02  2.92101553E+01  9.28666296E+00
  3.16392696E+00  7.86827235E+00  1.88128854E+00  5.44249258E-01  1.68714478E-01
  8.00000000E-01  1.87311370E+01  2.82539436E+00  6.40121692E-01  1.61277759E-01
  1.10000000E+00  1.87311370E+01  2.82539436E+00  6.40121692E-01  1.61277759E-01
  1.10000000E+00  1.87311370E+01  2.82539436E+00  6.40121692E-01  1.61277759E-01
  1.10000000E+00
Contraction coefficients                   R   N=          26
  1.83473713E-03  1.40373228E-02  6.88426223E-02  2.32184443E-01  4.67941348E-01
  3.62311985E-01 -1.19332420E-01 -1.60854152E-01  1.14345644E+00  1.00000000E+00
  1.00000000E+00  3.34946043E-02  2.34726953E-01  8.13757326E-01  1.00000000E+00
  1.00000000E+00  3.34946043E-02  2.34726953E-01  8.13757326E-01  1.00000000E+00
  1.00000000E+00  3.34946043E-02  2.34726953E-01  8.13757326E-01  1.00000000E+00
  1.00000000E+00
</code></pre></div></div> <p>For SP shell(<code class="language-plaintext highlighter-rouge">-1</code> in Shell types), we only take the coefficients of the last three basis gtfs in <code class="language-plaintext highlighter-rouge">P(S=P) Contraction coefficients</code>, i.e. the P type Shells of sp shell are using the coefficients in <code class="language-plaintext highlighter-rouge">P(S=P) Contraction coefficients</code>.</p> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">shl_type</span><span class="p">(</span><span class="n">ishl</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="ow">.and.</span><span class="w"> </span><span class="n">ibsshl</span><span class="w"> </span><span class="p">/</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
    </span><span class="c1">! sp type shell, and the last three GTFs are p-functions</span><span class="w">
    </span><span class="n">basis</span><span class="o">%</span><span class="n">gtfcoeff</span><span class="p">(</span><span class="n">ictr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SP_ctr_cff</span><span class="p">(</span><span class="n">ictr</span><span class="o">+</span><span class="n">iprim</span><span class="mi">-1</span><span class="p">)</span><span class="w"> 
</span><span class="k">else</span><span class="w">
    </span><span class="c1">! sp type shell, the first is s-function</span><span class="w">
    </span><span class="n">basis</span><span class="o">%</span><span class="n">gtfcoeff</span><span class="p">(</span><span class="n">ictr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctr_cff</span><span class="p">(</span><span class="n">ictr</span><span class="o">+</span><span class="n">iprim</span><span class="mi">-1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P(S=P) Contraction coefficients            R   N=          26
  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00
  0.00000000E+00  6.89990666E-02  3.16423961E-01  7.44308291E-01  1.00000000E+00
  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00
  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00
  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00
  0.00000000E+00
</code></pre></div></div> <h3 id="orbit-coefficients">Orbit coefficients:</h3> <p>We only concentrate on the number of the contracted basis shell, i.e. the sum of the components of corresponding shell types is the number of basis function used in the linear combination of orbits.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Alpha Orbital Energies                     R   N=          30
 -1.01884160E+01 -6.84051688E-01 -4.17833764E-01 -4.17833764E-01 -2.24551475E-01
  1.19389709E-01  1.85516107E-01  1.85516107E-01  5.35951550E-01  5.35951550E-01
  5.37185565E-01  6.81886841E-01  8.97771005E-01  8.97771005E-01  9.52649005E-01
  1.43519157E+00  1.43519157E+00  1.92622445E+00  1.92622445E+00  1.97602171E+00
  2.00907442E+00  2.28717507E+00  2.57565312E+00  2.57565312E+00  2.74315224E+00
  2.74315224E+00  3.28192103E+00  3.48818760E+00  3.48818760E+00  4.27195390E+00
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Alpha MO coefficients                      R   N=         900
</code></pre></div></div> <p>Which means the number of basis function is 30 = 1 + 4 + 4 + 6 + 1 + 1 + 3 + 1 + 1 + 3 + 1 + 1 + 3.</p> <h2 id="customized-basis-set">Customized basis set</h2> <p>shell definition block:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IType  NGauss  Sc	Shell descriptor line: shell type, # primitive gaussians, and scale factor.
α1  d1μ	Primitive gaussian specification: exponent and contraction coefficient.
α2  d2μ	
…	
αN  dNμ	There are a total of NGauss primitive gaussian lines.
</code></pre></div></div> <p>center definition block:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>atom num1-num2
</code></pre></div></div> <p>or</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num1-num2
</code></pre></div></div> <p>num is the index of atom in gjf file, <code class="language-plaintext highlighter-rouge">num=0</code> denotes all all atoms for the given elements.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>atom 0
</code></pre></div></div> <p><strong>Tips:</strong> Use IOp(3/24=1) to print the basis set information in the output file.</p> <h3 id="all-electron-basis-set">All electron basis set</h3> <p>Use <code class="language-plaintext highlighter-rouge">gen</code> keyword to let Gaussian read the custom basis from the card section.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># m062x/gen
[blank line]
test
[blank line]
0 1
 C                 -0.00000000    0.00000000    0.00000000
 H                 -0.00000000    0.00000000    1.09000000
 H                 -0.00000000   -1.02766186   -0.36333333
 H                 -0.88998127    0.51383093   -0.36333333
 H                  0.88998127    0.51383093   -0.36333333
[blank line]
C 0   
6-311G*
****
H 0   
6-31G**
****
</code></pre></div></div> <h3 id="pseudopotential--the-corresponding-pseudopotential-basis-sets">Pseudopotential + the corresponding pseudopotential basis sets</h3> <p>Use <code class="language-plaintext highlighter-rouge">genecp</code> keyword to let Gaussian read the custom basis from the card section.</p> <p>There are two parts of pesudopotential basis set, one is the pesudopotential itself to replace the core electrons, the other is the basis set for the valence electrons.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># b3lyp/genecp
[blank line]
test
[blank line]
0 1
coordinates
[blank line]
atom1 0
basis set for atom1
****
atom2 0
basis set for atom2
****
[blank line]
ecp for atom1
ecp for atom2
[blank line]
[blank line]
</code></pre></div></div> <h2 id="fix-the-unconverged-problems-in-geometry-optimization-tasks">Fix the unconverged problems in geometry optimization tasks</h2> <p>The iteration of the geometry optimization task contains two loops:</p> <ul> <li> <p>The outer loop is the iteration of the geometry optimization task, which the position of atoms are updated in each iteration. They are devided by “gradgradgradgradgrad”, and the convergence criteria is shown as follwing:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          Item               Value     Threshold  Converged?
  Maximum Force            0.016519     0.000450     NO 
  RMS     Force            0.003187     0.000300     NO 
  Maximum Displacement     0.061719     0.001800     NO 
  RMS     Displacement     0.011314     0.001200     NO 
</code></pre></div> </div> </li> </ul> <p>Here <code class="language-plaintext highlighter-rouge">Maximum Force</code> and <code class="language-plaintext highlighter-rouge">RMS Force</code> are the maximum and root-mean-square of the force on each atom, and <code class="language-plaintext highlighter-rouge">Maximum Displacement</code> and <code class="language-plaintext highlighter-rouge">RMS Displacement</code> are the maximum and root-mean-square of the displacement of each atom.</p> <ul> <li> <p>The inner loop between each geometry optimization step is SCF steps, named “Cycle”. The convergence criteria is shown as follwing:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">RMSDP</span><span class="o">=</span>1.38D-05 <span class="nv">MaxDP</span><span class="o">=</span>6.22D-04 <span class="nv">DE</span><span class="o">=</span><span class="nt">-1</span>.02D-05 <span class="nv">OVMax</span><span class="o">=</span> 9.68D-04
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1. **RMSDP (Root Mean Square Density Matrix Change)**:   - This is the root mean square (RMS) change in the density matrix between the current and the previous SCF iteration.   - A smaller RMSDP value indicates that changes in the electronic density from one iteration to the next are getting smaller, which is a sign of approaching convergence.  - `RMSDP=1.38D-05` suggests a relatively small change in the density matrix, indicating that the SCF calculation is nearing convergence.
</code></pre></div> </div> </li> </ul> <ol> <li><strong>MaxDP (Maximum Density Matrix Change)</strong>: <ul> <li>This is the maximum change in any element of the density matrix between the current and the previous SCF iteration.</li> <li>A lower MaxDP value is desired for convergence; it indicates that the largest change in the electron density at any point in space is becoming smaller.</li> <li><code class="language-plaintext highlighter-rouge">MaxDP=6.22D-04</code> is the value for the current iteration.</li> </ul> </li> <li><strong>DE (Change in Total Energy)</strong>: <ul> <li>This represents the change in total electronic energy between the current and the previous SCF iteration.</li> <li>The goal is to have a very small DE, indicating that the energy is stabilizing and the system is reaching a steady state.</li> <li><code class="language-plaintext highlighter-rouge">DE=-1.02D-05</code> is the energy change in the latest iteration.</li> </ul> </li> <li><strong>OVMax (Maximum Overlap Matrix Error)</strong>: <ul> <li>OVMax is related to the largest error in the overlap matrix between the current SCF density and the density used to build the Fock matrix.</li> <li>This parameter is often used in direct inversion in the iterative subspace (DIIS) procedures to improve SCF convergence. A smaller OVMax value indicates better convergence.</li> <li><code class="language-plaintext highlighter-rouge">OVMax= 9.68D-04</code> represents the maximum overlap matrix error for this iteration.</li> </ul> </li> </ol> <h3 id="the-method-to-fix-unconverged-problems">The method to fix unconverged problems</h3> <ul> <li> <p>if convergence porblems occur in the outer loop, it’s the problem of the geometry optimization task, see <a href="http://sobereva.com/164">Tian Lu’s blog</a>.</p> <p>There are mainly two ways that are most used:</p> <ul> <li> <p>increase the number of opt iterations, by setting <code class="language-plaintext highlighter-rouge">opt=maxcyc=N</code>, if result is near the convergence point.</p> </li> <li> <p>change other method, or loose the convergence criteria.</p> </li> </ul> </li> <li> <p>if unconvergence happens in the inner loop, then it’s the SCF problem, also mentioned in <a href="http://sobereva.com/61">Tian Lu’s bolg</a></p> <p>There are mainly four ways that are most used:</p> <ul> <li> <p>loose the convergence criteria, by setting <code class="language-plaintext highlighter-rouge">scf=conver=6</code>(<code class="language-plaintext highlighter-rouge">scf=conver=8</code> is the default value), together with <code class="language-plaintext highlighter-rouge">IOp(7/127=-99) IOp(8/117=-99)</code> to avoid the error of the SCF procedure.</p> </li> <li> <p>set <code class="language-plaintext highlighter-rouge">scf=vshift=N</code>(for heavy atoms or metal) N is a value between 300 to 500, to boarden the interval between LUMO and HOMO, without changing the final result.</p> </li> <li> <p>set larger iteration cycles <code class="language-plaintext highlighter-rouge">scf=maxcyc=N</code></p> </li> <li> <p>use the old converged output filed as the inital guess of wave function, by setting the correct chk file path and <code class="language-plaintext highlighter-rouge">guess=read</code>, <code class="language-plaintext highlighter-rouge">geom=check</code>. <strong>Remember the charge and spin multiplicity should be set</strong>, i.e.</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  %chk=path/to/old_checkpoint.chk
  #p B3LYP/6-31G(d) SP Geom=Check Guess=Read

  Title Section

  0 1
</code></pre></div> </div> </li> </ul> <p><strong>Notice:</strong> the output from this modified is only the result of a corase calculation, especially for the modification on the convergence criteria. Calculation task with defauly sets is needed after the convergence of the initial guess.</p> <p><strong>Notice:</strong> <code class="language-plaintext highlighter-rouge">scf=conver=6</code> and <code class="language-plaintext highlighter-rouge">IOp(7/127=-99) IOp(8/117=-99)</code> could only avoid the SCF error in the geometry optimization process, at the end of the calculation task, in the analysis of the physical inforamtion, SCF error is still raised. Then I suggest to use this “fault”(I mean, SCF done by only error in the calculation of physical quantities) as the initial guess of the new task with all criteria are set as default.</p> <h2 id="fix-the-imaginary-frequency-in-frequency-calculation">Fix the imaginary frequency in frequency calculation</h2> <p><strong>Notice</strong></p> <p>IOp won’t inherit to the new task, so opt and freq should be seperated if IOp is used.</p> <p>Use <code class="language-plaintext highlighter-rouge">opt=(tight,recalc=n)</code>(n=3-5) to enhance the accuracy of the geometry optimization.</p> <h2 id="fix-some-errors-in-utility-programs-of-gaussian">Fix some errors in Utility Programs of Gaussian</h2> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Out-of-memory error in <code class="language-plaintext highlighter-rouge">formchk</code>: <code class="language-plaintext highlighter-rouge">export GAUSS_MEMDEF=12GB</code></li> </ul> <h2 id="the-optimazation-of-wave-function">The optimazation of wave function</h2> <h3 id="keywords-stable">keywords <code class="language-plaintext highlighter-rouge">stable</code></h3> <p><code class="language-plaintext highlighter-rouge">stable</code> is used to check the stability of the wave function, we could check it in the output file by searching <code class="language-plaintext highlighter-rouge">Stability analysis</code> string. More details are discussed in this <a href="http://blog.molcalx.com.cn/2018/12/19/gaussian-wavefunction-stability.html">website</a>.</p> <p>Furthermore, we could use <code class="language-plaintext highlighter-rouge">stable=opt</code> to optimize the wave function, which is used to fix the problem of the wave function.</p> <h3 id="spin-polarized-statesymmetry-broken-state">Spin-Polarized state/Symmetry-Broken state</h3> <p>Spin-Polarized state is the state with the broken spin symmetry, though it’s the state with closed shell, the alpha and beta electrons are not equal, i.e. there is difference between the distribution of those two electrons. However, the default guess of Gaussian is the restricted closed shell wave function, which is often not good enough. Seen in <a href="http://sobereva.com/82">Tian Lu’ Blog</a>, <code class="language-plaintext highlighter-rouge">stable=opt</code> is also used to fix the problem of the initial wave function.</p> <h2 id="some-iop-format">Some IOp format</h2> <p><code class="language-plaintext highlighter-rouge">IOp(3/130)</code></p> <p>Coefficient of full range of HF exchange.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-1	0 full range coefficient.
0	Standard full range HF exchange.
NNNNN	NNNNN/10000 full range coefficient.
100000	Use the negative of the short range coefficient as set by IOp(3/119).
200000	Set the short range coefficient to zero.
1000000	Use the negative of the long range coefficient as set by IOp(3/119).
2000000	Set the long range coefficient to zero.
10000000	Use the negative of the mid range coefficient as set by IOp(138).
20000000	Set the mid range coefficient to zero.
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">IOp(3/131)</code></p> <p>Coefficient of full range of DFT exchange.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-1	0 full range coefficient.
0	Standard full range DFT exchange.
NNNNN	NNNNN/10000 full range coefficient.
100000	Use the negative of the short range coefficient as set by IOp(3/120).
200000	Set the short range coefficient to zero.
1000000	Use the negative of the long range coefficient as set by IOp(3/120).
2000000	Set the long range coefficient to zero.
</code></pre></div></div>]]></content><author><name></name></author><category term="DFT"/><category term="Gaussian"/><category term="DFT"/><summary type="html"><![CDATA[Input format]]></summary></entry><entry><title type="html">Tips for NWChem</title><link href="https://liangguangyii.github.io/blog/2024/notes-for-nwchem/" rel="alternate" type="text/html" title="Tips for NWChem"/><published>2024-02-13T00:00:00+00:00</published><updated>2024-02-13T00:00:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-for-nwchem</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-for-nwchem/"><![CDATA[<h2 id="use-external-basis-set">Use external basis set</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>basis spherical
Au library def2-TZVPD file /home/phys/liangguangyi/opt/NWChem/src/nwchem-7.2.2/src/basis/libraries.bse/def2-tzvpd
V  library def2-TZVPD file /home/phys/liangguangyi/opt/NWChem/src/nwchem-7.2.2/src/basis/libraries.bse/def2-tzvpd
end
ecp
Au library def2-TZVPD file /home/phys/liangguangyi/opt/NWChem/src/nwchem-7.2.2/src/basis/libraries.bse/def2-tzvpd
end
dft
</code></pre></div></div> <p>NWChem will search the keyword “Au_def2-TZVPD” or “V_def2-TZVPD” in the file <code class="language-plaintext highlighter-rouge">def2-tzvpd</code> in the path <code class="language-plaintext highlighter-rouge">/home/phys/liangguangyi/opt/NWChem/src/nwchem-7.2.2/src/basis/libraries.bse/</code>.</p> <p>And DO REMEMBER to add ECP for ECP basis set.</p> <h2 id="beyond-hf-method">beyond HF method</h2> <p>NWChem could change the initial guess for beyond HF method by setting the keyword <code class="language-plaintext highlighter-rouge">scf</code> or <code class="language-plaintext highlighter-rouge">dft</code> before the method keyword.</p>]]></content><author><name></name></author><category term="DFT"/><category term="NWChem"/><category term="DFT"/><summary type="html"><![CDATA[Use external basis set]]></summary></entry><entry><title type="html">Notes for Fortran</title><link href="https://liangguangyii.github.io/blog/2024/notes-for-fortran/" rel="alternate" type="text/html" title="Notes for Fortran"/><published>2024-02-11T00:00:00+00:00</published><updated>2024-02-11T00:00:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-for-fortran</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-for-fortran/"><![CDATA[<h2 id="basic-functions">Basic functions</h2> <h3 id="subroutine">subroutine</h3> <p>subroutine could return multiple values, and it is called by <code class="language-plaintext highlighter-rouge">call</code> statement.</p> <h3 id="function">function</h3> <p>In general, function could only return one value, however it could also return multiple values by stored them in ‘type’ variable.</p> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">func_name</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">arg3</span><span class="p">)</span><span class="w">
    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">arg3</span><span class="w">
    </span><span class="n">func_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg3</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">func_name</span><span class="w">

</span><span class="k">function</span><span class="w"> </span><span class="n">func_name</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">arg3</span><span class="p">)</span><span class="w"> </span><span class="k">result</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span><span class="w">
    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">arg3</span><span class="w">
    </span><span class="k">type</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">result_name</span><span class="w">
    </span><span class="n">result_name</span><span class="o">%</span><span class="n">value1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg3</span><span class="w">
    </span><span class="n">result_name</span><span class="o">%</span><span class="n">value2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">arg3</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">func_name</span><span class="w">
</span></code></pre></div></div> <h2 id="file-io">File I/O</h2> <h3 id="read"><code class="language-plaintext highlighter-rouge">read</code></h3> <p><strong>In Fortran, <code class="language-plaintext highlighter-rouge">read</code> function will not read the last line of file, if the last line is empty.</strong></p> <h3 id="rewind"><code class="language-plaintext highlighter-rouge">rewind</code></h3> <h2 id="trigonometric-functions">Trigonometric functions</h2> <h3 id="xxx-and-xxxd"><code class="language-plaintext highlighter-rouge">xxx</code> and <code class="language-plaintext highlighter-rouge">xxxd</code></h3> <p>Trigonometric or anti-trigonometric functions with <code class="language-plaintext highlighter-rouge">d</code> suffix, such as <code class="language-plaintext highlighter-rouge">sin</code> and <code class="language-plaintext highlighter-rouge">sind</code>, <code class="language-plaintext highlighter-rouge">cos</code> and <code class="language-plaintext highlighter-rouge">cosd</code>, <code class="language-plaintext highlighter-rouge">tan</code> and <code class="language-plaintext highlighter-rouge">tand</code>, <code class="language-plaintext highlighter-rouge">asin</code> and <code class="language-plaintext highlighter-rouge">asind</code>, <code class="language-plaintext highlighter-rouge">acos</code> and <code class="language-plaintext highlighter-rouge">acosd</code>, <code class="language-plaintext highlighter-rouge">atan</code> and <code class="language-plaintext highlighter-rouge">atand</code>, are used to calculate the angle in degree.</p> <p>And the functions without <code class="language-plaintext highlighter-rouge">d</code> suffix are used to calculate the angle in radian.</p> <h3 id="atan-and-atan2"><code class="language-plaintext highlighter-rouge">atan</code> and <code class="language-plaintext highlighter-rouge">atan2</code></h3> <p><code class="language-plaintext highlighter-rouge">atan2</code> ouputs the true augument of the input parameters.</p> <p>The input parameters of <code class="language-plaintext highlighter-rouge">atan2(y,x)</code> are two real numbers <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">x</code>, corresponding to y/x, the output range is from -π to π, different from <code class="language-plaintext highlighter-rouge">atan</code>, which is from -π/2 to π/2.</p> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="nb">atan2</span><span class="p">(</span><span class="mf">1D0</span><span class="p">,</span><span class="w"> </span><span class="mf">1D0</span><span class="p">)</span><span class="w">    </span><span class="c1">!0.7853981633974483</span><span class="w">
</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="nb">atan2</span><span class="p">(</span><span class="mf">1D0</span><span class="p">,</span><span class="w"> </span><span class="mf">-1D0</span><span class="p">)</span><span class="w">   </span><span class="c1">!2.356194490192345</span><span class="w">
</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="nb">atan2</span><span class="p">(</span><span class="mf">-1D0</span><span class="p">,</span><span class="w"> </span><span class="mf">-1D0</span><span class="p">)</span><span class="w">  </span><span class="c1">!-2.356194490192345</span><span class="w">
</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="nb">atan2</span><span class="p">(</span><span class="mf">-1D0</span><span class="p">,</span><span class="w"> </span><span class="mf">1D0</span><span class="p">)</span><span class="w">   </span><span class="c1">!-0.7853981633974483</span><span class="w">

</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="nb">atan</span><span class="p">(</span><span class="mf">1D0</span><span class="p">)</span><span class="w">          </span><span class="c1">!0.7853981633974483</span><span class="w">
</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="nb">atan</span><span class="p">(</span><span class="mf">-1D0</span><span class="p">)</span><span class="w">         </span><span class="c1">!-0.7853981633974483</span><span class="w">
</span></code></pre></div></div>]]></content><author><name></name></author><category term="code"/><category term="Fortran"/><category term="Computer Science"/><summary type="html"><![CDATA[Basic functions]]></summary></entry><entry><title type="html">Notes for vmd</title><link href="https://liangguangyii.github.io/blog/2024/notes-for-vmd/" rel="alternate" type="text/html" title="Notes for vmd"/><published>2024-02-11T00:00:00+00:00</published><updated>2024-02-11T00:00:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-for-vmd</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-for-vmd/"><![CDATA[<h2 id="molecule_number-and-rep_number">molecule_number and rep_number</h2> <p>molecule_number is the index of the molecule in the molecule list, and it is not reusued after the molecule is deleted. <strong>Thus it’s truely inconvenient when using command line, and we could use <code class="language-plaintext highlighter-rouge">top</code> to represent the molID in the bottom of the current molecule list.</strong></p> <p>rep_number is the index of the representation in the representation list, with respect to the molecule_number.</p> <h2 id="mol-command"><code class="language-plaintext highlighter-rouge">mol</code> command</h2> <p><a href="https://www.ks.uiuc.edu/Research/vmd/current/ug/node140.html">mol introduction</a>, and <a href="https://www.ks.uiuc.edu/Research/vmd/current/ug/node142.html#ug:topic:molinfo">molinfo command</a></p> <p>subcommands:</p> <ul> <li><code class="language-plaintext highlighter-rouge">new</code>: add new molecule from a file, if it’s blank, then it will create with no atoms.</li> <li><code class="language-plaintext highlighter-rouge">addfile</code>: similar with <code class="language-plaintext highlighter-rouge">add</code>, except it will bind the new file and former file together, they will share with the same molID, and by using the command like <code class="language-plaintext highlighter-rouge">mol modcolor rep_ID mol_ID volume 1</code>, we could map the values of the latter file to the isosurface of the former file(where <code class="language-plaintext highlighter-rouge">1</code> is the index, start by 0, of the binding files in the molID).</li> <li><code class="language-plaintext highlighter-rouge">delete</code> molecule_number: Delete molecule(s).</li> <li><code class="language-plaintext highlighter-rouge">modcolor</code> rep_number molecule_number coloring_method: Change the current coloring method for the given representation in the specified molecule.</li> <li><code class="language-plaintext highlighter-rouge">modmaterial</code> rep_number molecule_number material_name: Change the current material for the given representation in the specified molecule.</li> <li><code class="language-plaintext highlighter-rouge">modstyle</code> rep_number molecule_number rep_style: Change the current rendering method (style) for the given representation in the specified molecule.</li> <li> <p><code class="language-plaintext highlighter-rouge">modselect</code> rep_number molecule_number select_method: Change the current selection for the given representation in the specified molecule.</p> </li> <li><code class="language-plaintext highlighter-rouge">scaleminmax</code> molecule_number rep_number [min max / auto]: Get/set the color scale range for this rep. Normally the color scale is automatically scaled to the minimum and maximum of the corresponding range of data. This command overrides the autoscaled values with the values you specify. Omit the min and max arguments to get the current values. Use ``auto” instead of a min and max to rescale the color scale to the maximum range again.</li> </ul> <p>code to delete all molID in vmd:</p> <div class="language-tcl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach i <span class="p">[</span>molinfo list<span class="p">]</span> <span class="p">{</span>
mol delete $i
<span class="p">}</span>
</code></pre></div></div> <h2 id="custom-colormap">Custom colormap</h2> <p>The colormap could be customized by <code class="language-plaintext highlighter-rouge">color change rgb[$i] $r $g $b</code>, and the <code class="language-plaintext highlighter-rouge">$i</code> is the index of the color in the colormap, and the <code class="language-plaintext highlighter-rouge">$r</code>, <code class="language-plaintext highlighter-rouge">$g</code>, <code class="language-plaintext highlighter-rouge">$b</code> are the RGB values of the color.</p> <div class="language-tcl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proc mycolor_scale <span class="p">{}</span> <span class="p">{</span>
  set color_start <span class="p">[</span>colorinfo num<span class="p">]</span>
  display update off

  set colors<span class="p">(</span>0<span class="p">)</span> <span class="p">[</span>list 1.0 1.0 1.0<span class="p">]</span>  
  set colors<span class="p">(</span>256<span class="p">)</span> <span class="p">[</span>list 0.0 0.0 1.0<span class="p">]</span>  
  set colors<span class="p">(</span>512<span class="p">)</span> <span class="p">[</span>list 1.0 0.0 0.0<span class="p">]</span>  
  set colors<span class="p">(</span>768<span class="p">)</span> <span class="p">[</span>list 0.0 1.0 0.0<span class="p">]</span>  
    
  

  for <span class="p">{</span>set i 0<span class="p">}</span> <span class="p">{</span><span class="nv">$i</span> &lt; 1024<span class="p">}</span> <span class="p">{</span>incr i<span class="p">}</span> <span class="p">{</span>
    if <span class="p">{</span><span class="nv">$i</span> &lt; 256<span class="p">}</span> <span class="p">{</span>
      set ratio <span class="p">[</span>expr double<span class="p">(</span><span class="nv">$i</span><span class="p">)</span> / 256.0<span class="p">]</span>
      set r <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>0<span class="p">)</span> 0<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>256<span class="p">)</span> 0<span class="p">]]</span>
      set g <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>0<span class="p">)</span> 1<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>256<span class="p">)</span> 1<span class="p">]]</span>
      set b <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>0<span class="p">)</span> 2<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>256<span class="p">)</span> 2<span class="p">]]</span>
    <span class="p">}</span> elseif <span class="p">{</span><span class="nv">$i</span> &lt; 512<span class="p">}</span> <span class="p">{</span>
      set ratio <span class="p">[</span>expr double<span class="p">(</span><span class="nv">$i</span> - 256<span class="p">)</span> / 256.0<span class="p">]</span>
      set r <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>256<span class="p">)</span> 0<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>512<span class="p">)</span> 0<span class="p">]]</span>
      set g <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>256<span class="p">)</span> 1<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>512<span class="p">)</span> 1<span class="p">]]</span>
      set b <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>256<span class="p">)</span> 2<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>512<span class="p">)</span> 2<span class="p">]]</span>
    <span class="p">}</span> elseif <span class="p">{</span><span class="nv">$i</span> &lt; 768<span class="p">}</span> <span class="p">{</span>
      set ratio <span class="p">[</span>expr double<span class="p">(</span><span class="nv">$i</span> - 512<span class="p">)</span> / 256.0<span class="p">]</span>
      set r <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>512<span class="p">)</span> 0<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>768<span class="p">)</span> 0<span class="p">]]</span>
      set g <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>512<span class="p">)</span> 1<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>768<span class="p">)</span> 1<span class="p">]]</span>
      set b <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>512<span class="p">)</span> 2<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>768<span class="p">)</span> 2<span class="p">]]</span>
    <span class="p">}</span> else <span class="p">{</span>
      set ratio <span class="p">[</span>expr double<span class="p">(</span><span class="nv">$i</span> - 768<span class="p">)</span> / 255.0<span class="p">]</span>
      set r <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>768<span class="p">)</span> 0<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>0<span class="p">)</span> 0<span class="p">]]</span>
      set g <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>768<span class="p">)</span> 1<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>0<span class="p">)</span> 1<span class="p">]]</span>
      set b <span class="p">[</span>expr <span class="p">(</span>1.0 - $ratio<span class="p">)</span> * <span class="p">[</span>lindex $colors<span class="p">(</span>768<span class="p">)</span> 2<span class="p">]</span> + $ratio * <span class="p">[</span>lindex $colors<span class="p">(</span>0<span class="p">)</span> 2<span class="p">]]</span>
    <span class="p">}</span>

  color change rgb <span class="p">[</span>expr $i + $color_start     <span class="p">]</span> $r $g $b
  <span class="p">}</span>
  display update on
<span class="p">}</span>
</code></pre></div></div> <p>It will be activated by using the colormap command such as <code class="language-plaintext highlighter-rouge">mol scaleminmax molID repID min max</code> once again.</p>]]></content><author><name></name></author><category term="code"/><category term="vmd"/><category term="Visualisation"/><summary type="html"><![CDATA[molecule_number and rep_number molecule_number is the index of the molecule in the molecule list, and it is not reusued after the molecule is deleted. Thus it’s truely inconvenient when using command line, and we could use top to represent the molID in the bottom of the current molecule list.]]></summary></entry><entry><title type="html">Notes for ORCA</title><link href="https://liangguangyii.github.io/blog/2024/notes-for-orca/" rel="alternate" type="text/html" title="Notes for ORCA"/><published>2024-01-03T00:00:00+00:00</published><updated>2024-01-03T00:00:00+00:00</updated><id>https://liangguangyii.github.io/blog/2024/notes-for-orca</id><content type="html" xml:base="https://liangguangyii.github.io/blog/2024/notes-for-orca/"><![CDATA[<h2 id="auxiliary-basis-set">Auxiliary Basis Set</h2> <p>In the Chap9.5 of the manual, it says:</p> <p>NOTES:</p> <ul class="task-list"> <li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>The RI-J approximation requires an auxiliary basis set” in addition to a normal orbital basis set. For the Karlsruhe basis sets there is the universal auxiliary basis set of Weigend that is called with the name def2/J (all-electron up to Kr). When scalar relativistic Hamiltonians are used (DKH or ZORA) along with all-electron basis sets, then a general-purpose auxiliary basis set is the SARC/J that covers most of the periodic table. Other choices are documented in sections 6.3 and 9.5.</p> </li> <li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>For pure” functionals the use of RI-J with the def2/J auxiliary basis set is the default.</p> </li> </ul> <p>The basis set is specified in the block <code class="language-plaintext highlighter-rouge">%BASIS</code>. Note that there are three distinguished slots for auxiliary basis sets (AuxJ, AuxC and AuxJK) to be used with RI approximation. Which auxiliary basis slot is used in the actual program depends on the context. The AuxJ and AuxJK slots are used in the context of Fock matrix construction, whereas the AuxC slot is used for all other integral generation steps e.g. in post-Hartree Fock methods. Assigning the auxiliary basis with the simple input, takes care of the individual slots. However, in specific cases they must be set explicitly in the block input. For example, a /JK” basis may be assigned to AuxJ in this way</p> <h2 id="using-the-calculation-results-for-initial-guess">Using the calculation results for initial guess</h2> <p>More details see in <a href="http://sobereva.com/517">Tian Lu’s blog</a>, he’s a fucking kami-sama.</p> <p>There are several points that should be notices:</p> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>We should using <code class="language-plaintext highlighter-rouge">int=NoBasisTransform</code> in gjf document to avoid the situation that gaussian delete the repeated basis functions.</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Using <code class="language-plaintext highlighter-rouge">IOp(3/32=2)</code> to keep the linear-dependent basis function.</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>And be careful, the wave function is in the standard oreientation.</li> </ul>]]></content><author><name></name></author><category term="DFT"/><category term="PRCA"/><category term="DFT"/><summary type="html"><![CDATA[Auxiliary Basis Set]]></summary></entry></feed>